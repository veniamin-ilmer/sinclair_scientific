//! This ROM was painstakingly optically copied from the chip, bit by bit.

use arbitrary_int::{u11,u4};

fn get_word(rom: &[u64;55], addr: u16) -> u11 {

    let addr_high = addr >> 6;
    let x_addr = addr & 0b111111;
    
    let (y1, y2) = match addr_high {
        0 => (4, 5),
        1 => (3, 6),
        2 => (2, 7),
        3 => (1, 8),
        _ => (0, 9),
    };

    let bita = (!(rom[y1] >> x_addr) & 0b1) as u16;
    let bit9 = (!(rom[y2] >> x_addr) & 0b1) as u16;
    let bit8 = (!(rom[10 + y1] >> x_addr) & 0b1) as u16;
    let bit7 = (!(rom[10 + y2] >> x_addr) & 0b1) as u16;
    let bit6 = (!(rom[20 + y1] >> x_addr) & 0b1) as u16;
    let bit5 = (!(rom[20 + y2] >> x_addr) & 0b1) as u16;
    let bit4 = (!(rom[30 + y1] >> x_addr) & 0b1) as u16;
    let bit3 = (!(rom[30 + y2] >> x_addr) & 0b1) as u16;
    let bit2 = (!(rom[40 + y1] >> x_addr) & 0b1) as u16;
    let bit1 = (!(rom[40 + y2] >> x_addr) & 0b1) as u16;
    let bit0 = (!(rom[50 + y1] >> x_addr) & 0b1) as u16;
    u11::new((bita << 10) + (bit9 << 9) + (bit8 << 8) + (bit7 << 7) + (bit6 << 6) + (bit5 << 5) + (bit4 << 4) + (bit3 << 3) + (bit2 << 2) + (bit1 << 1) + bit0)
}

pub fn decode() -> [u11; 320] {
  let rom: [u64;55] = [
    0b1000000101001000001000001110010001010010000100010000000000100100,
    0b0000000001001010101001010000101000001000011010110100100000000000,
    0b0000000100000100101000010100010101000010100010011000010100101010,
    0b1001001001001001000001010010010100101100010100101001001000101001,
    0b0001010101010100100100001001000001010100000000000001000100000000,
    0b0000110101101111111100011001000101101000011111111011111011000011,
    0b1001000000011001000000110111101100101000010100100001000000101001,
    0b0000000000000100111100010001110101011101100000011000010100100001,
    0b0000000001000000111001111000111000001000011001100110110000000000,
    0b0100000101101000001000001101010000010000000011001000000000100010,

    0b0000101111001010011000011100000100101101001100100010000100110001,
    0b0010000001101111101011010011101000001010111110111101100001100000,
    0b0010000110001101101001010110011111100010111111011110011110111100,
    0b1101111100001111100101011010010110111110011110101101101110111101,
    0b0101011111010100100110001101101001010100011111111001000100000000,
    0b0110011111000111111111111101001111010110111111111111111111111110,
    0b1001101011101111001110011001100111100111101100101011011001101001,
    0b0000111000011011000010101001111010001110010000100101100001001010,
    0b0010111110010000000110010111000111110101000000000001000000101110,
    0b1010111000111111111111111010111111111010111000110110000000000100,

    0b1110101010100101111100111111110001111110111010011111111100000111,
    0b1100100100100000011100101100011000001101001001010011111111100001,
    0b1110000010111111111111110110011111011001111110011111111100101011,
    0b0010110001110110101010101110011001001001111010010110010011000100,
    0b0011111111111100111110001101110011111111111100111001001100101101,
    0b0000001110100111100111101110111010101100010000000011010101110101,
    0b0010100001100111000000001111100000111100011100111001101110111001,
    0b1101000011111010000001100011110110110000111111011111111111111100,
    0b1101011110100101001000001111001000000000110110100101001110011111,
    0b1100111010000001100100101100110110011010110001100001111001001010,

    0b0100010000000001110100111111101011100101111011111001111001000001,
    0b1110111110000000011011111010111000000010000101000010011110000000,
    0b0010111100100001010110110101111001010011000000011001110101001001,
    0b0000100000110110010111110111111000011000011001110001001010111011,
    0b1111100100011111100110101101010011010101001011000001101110011101,
    0b1101101110111111111111111111110111101111100101101110111111111111,
    0b1010100111101110111100101111011110011111111011011110010111110111,
    0b1110111100100001111110011010111011111111011111111111101011111011,
    0b1111100111111101011110011111011111110111000110001110111110101111,
    0b1111010000111110110111110101001011100101011011101111111010000111,

    0b0100100001000001000111001111010001111000000000100001111101011000,
    0b0001111101000010101110101111101111111000101001011101001110101111,
    0b1110111101000111100011100101001001010101100000000000000000111100,
    0b0101010000010110000100110111111111011001010111001010111011011001,
    0b1100111001001010001011100011110011011011110111111011110011101111,
    0b0101001101010101101101001100010011011110101111001111110011111111,
    0b0011101110101101001100010101000001000111101111010010010001001001,
    0b1111111010111101001111111100011001010101100000111000010001101011,
    0b1110111011010010010111010111100111111111011100110001011111111111,
    0b0011011110011110111011110010011010010111011100101111111011101001,

    0b1011010000010110110111111110011010011101111000110111111010000001,
    0b1110111111110011001111010111001111110111110100100100001111111111,
    0b1111111100110001001010001010011000111110111110111111001101001110,
    0b0111110010101011001101000010000110011010111000111111110011011000,
    0b1100000100010100100111101101010110110110100000001110110111111111,
  ];
  
  let mut decoded_rom = Vec::with_capacity(320);
  
  for addr in 0..320 {
    decoded_rom.push(get_word(&rom, addr));
  }
  decoded_rom.try_into().unwrap()
}

pub const WORD_SELECTS: [u11; 16] = [
  u11::new(0b11111111111),
  u11::new(0b10000000000),
  u11::new(0b00110000000),
  u11::new(0b00001000000),
  u11::new(0b00001111111),
  u11::new(0b00000000001),
  u11::new(0b00110000000),
  u11::new(0b01000000000),
  u11::new(0b11111100000),
  u11::new(0b11110000000),
  u11::new(0b00001111111),
  u11::new(0b00000100000),
  u11::new(0b00001111100),
  u11::new(0b00001111100),
  u11::new(0b00001000000),
  u11::new(0b00001000000),
];

pub const CONSTANTS: [u4; 16] = [
  u4::new(0),
  u4::new(5),
  u4::new(0),
  u4::new(1),
  u4::new(0),
  u4::new(1),
  u4::new(1),
  u4::new(5),
  u4::new(0),
  u4::new(1),
  u4::new(1),
  u4::new(1),
  u4::new(5),
  u4::new(1),
  u4::new(4),
  u4::new(0),
];

use chips::tms0800::alu::*;
pub const ALU_OPCODES: [Opcode; 32] = [
  Opcode::new(Dest::A, Arg1::A, Oper::Plus, Arg2::B, false),                //0: A = A + B
  Opcode::new(Dest::A, Arg1::A, Oper::Plus, Arg2::K, false),                //1: A = A + K
  Opcode::new(Dest::C, Arg1::A, Oper::Plus, Arg2::K, false),                //2: C = A + K
  Opcode::new(Dest::B, Arg1::C, Oper::Plus, Arg2::B, false),                //3: B = C + B
  Opcode::new(Dest::C, Arg1::None, Oper::Plus, Arg2::B, false),             //4: C = B
  Opcode::new(Dest::A, Arg1::C, Oper::Plus, Arg2::K, false),                //5: A = C + K
  Opcode::new(Dest::B, Arg1::C, Oper::Plus, Arg2::K, false),                //6: B = C + K
  Opcode::new(Dest::A, Arg1::A, Oper::Minus, Arg2::B, false),               //7: A = A - B
  Opcode::new(Dest::C, Arg1::A, Oper::Minus, Arg2::B, false),               //8: C = A - B
  Opcode::new(Dest::A, Arg1::A, Oper::Minus, Arg2::K, false),               //9: A = A - K
  Opcode::new(Dest::C, Arg1::C, Oper::Minus, Arg2::B, false),               //10: C = C - B
  Opcode::new(Dest::C, Arg1::C, Oper::Minus, Arg2::K, false),               //11: C = C - K
  Opcode::new(Dest::None, Arg1::A, Oper::Minus, Arg2::B, false),            //12: A - B
  Opcode::new(Dest::None, Arg1::A, Oper::Minus, Arg2::K, false),            //13: A - K
  Opcode::new(Dest::None, Arg1::C, Oper::Minus, Arg2::B, false),            //14: C - B
  Opcode::new(Dest::None, Arg1::C, Oper::Minus, Arg2::K, false),            //15: C - K
  Opcode::new(Dest::A, Arg1::None, Oper::Plus, Arg2::K, false),             //16: A = K
  Opcode::new(Dest::B, Arg1::None, Oper::Plus, Arg2::K, false),             //17: B = K
  Opcode::new(Dest::C, Arg1::None, Oper::Plus, Arg2::K, false),             //18: C = K
  Opcode::new(Dest::None, Arg1::None, Oper::ExchangeAB, Arg2::None, false), //19: Exchange A and B
  Opcode::new(Dest::A, Arg1::A, Oper::Shl, Arg2::None, false),              //20: A = A << 4
  Opcode::new(Dest::B, Arg1::None, Oper::Shl, Arg2::B, false),              //21: B = B << 4
  Opcode::new(Dest::C, Arg1::C, Oper::Shl, Arg2::None, false),              //22: C = C << 4
  Opcode::new(Dest::A, Arg1::A, Oper::Shr, Arg2::None, false),              //23: A = A >> 4
  Opcode::new(Dest::B, Arg1::None, Oper::Shr, Arg2::B, false),              //24: B = B >> 4
  Opcode::new(Dest::C, Arg1::C, Oper::Shr, Arg2::None, false),              //25: C = C >> 4
  Opcode::new(Dest::A, Arg1::A, Oper::Wait, Arg2::K, false),                //26: A = A + K Wait
  Opcode::new(Dest::A, Arg1::C, Oper::Minus, Arg2::B, false),               //27: A = C - B
  Opcode::new(Dest::B, Arg1::C, Oper::Minus, Arg2::K, false),               //28: B = C - K
  Opcode::new(Dest::C, Arg1::C, Oper::Plus, Arg2::K, false),                //29: C = C + K
  Opcode::new(Dest::C, Arg1::A, Oper::Plus, Arg2::B, false),                //30: C = A + B
  Opcode::new(Dest::C, Arg1::C, Oper::Plus, Arg2::B, false),                //31: C = C + B
];